<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>2048 Battle - Timed Round (Fixed)</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
        @keyframes slideDown { from { transform: translateY(-100px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .animate-slide-down { animation: slideDown 0.5s ease-out; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const GRID_SIZE = 4;
        const COLORS = {
            2: 'bg-amber-100 text-amber-800',
            4: 'bg-amber-200 text-amber-900',
            8: 'bg-orange-300 text-white',
            16: 'bg-orange-400 text-white',
            32: 'bg-orange-500 text-white',
            64: 'bg-red-500 text-white',
            128: 'bg-yellow-400 text-white',
            256: 'bg-yellow-500 text-white',
            512: 'bg-yellow-600 text-white',
            1024: 'bg-green-500 text-white',
            2048: 'bg-green-600 text-white',
            4096: 'bg-blue-600 text-white',
        };

        const initGrid = () => {
            const grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
            addRandomTile(grid);
            addRandomTile(grid);
            return grid;
        };

        const addRandomTile = (grid) => {
            const empty = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === 0) empty.push([r, c]);
                }
            }
            if (empty.length > 0) {
                const [r, c] = empty[Math.floor(Math.random() * empty.length)];
                grid[r][c] = Math.random() < 0.9 ? 2 : 4;
            }
        };

        const moveLeft = (grid) => {
            let moved = false;
            let score = 0;
            const newGrid = grid.map(row => {
                const filtered = row.filter(cell => cell !== 0);
                const merged = [];
                let i = 0;
                while (i < filtered.length) {
                    if (i + 1 < filtered.length && filtered[i] === filtered[i + 1]) {
                        const val = filtered[i] * 2;
                        merged.push(val);
                        score += val;
                        i += 2;
                    } else {
                        merged.push(filtered[i]);
                        i++;
                    }
                }
                while (merged.length < GRID_SIZE) merged.push(0);
                if (JSON.stringify(merged) !== JSON.stringify(row)) moved = true;
                return merged;
            });
            return { grid: newGrid, moved, score };
        };

        const rotateGrid = (grid) => {
            const newGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    newGrid[c][GRID_SIZE - 1 - r] = grid[r][c];
                }
            }
            return newGrid;
        };

        const move = (grid, direction) => {
            let rotations = 0;
            let tempGrid = grid.map(row => [...row]);
            
            if (direction === 'up') rotations = 3;
            else if (direction === 'right') rotations = 2;
            else if (direction === 'down') rotations = 1;
            
            for (let i = 0; i < rotations; i++) {
                tempGrid = rotateGrid(tempGrid);
            }
            
            const result = moveLeft(tempGrid);
            
            for (let i = 0; i < (4 - rotations) % 4; i++) {
                result.grid = rotateGrid(result.grid);
            }
            
            return result;
        };

        const canMove = (grid) => {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === 0) return true;
                    if (c < GRID_SIZE - 1 && grid[r][c] === grid[r][c + 1]) return true;
                    if (r < GRID_SIZE - 1 && grid[r][c] === grid[r + 1][c]) return true;
                }
            }
            return false;
        };

        const aiMove = (grid) => {
            const directions = ['left', 'right', 'up', 'down'];
            const validMoves = directions.filter(dir => {
                const result = move(grid, dir);
                return result.moved;
            });
            
            if (validMoves.length === 0) return null;
            
            let bestMove = validMoves[0];
            let bestScore = -1;
            
            validMoves.forEach(dir => {
                const result = move(grid, dir);
                const emptyCount = result.grid.flat().filter(x => x === 0).length;
                const maxTile = Math.max(...result.grid.flat());
                const cornerBonus = (result.grid[0][0] === maxTile || result.grid[0][3] === maxTile) ? 100 : 0;
                const evalScore = result.score + emptyCount * 10 + cornerBonus;
                
                if (evalScore > bestScore) {
                    bestScore = evalScore;
                    bestMove = dir;
                }
            });
            
            return bestMove;
        };

        // Arrow SVG Components
        const ArrowUp = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" style={{margin: '0 auto'}}>
                <path d="M12 19V5M5 12l7-7 7 7"/>
            </svg>
        );

        const ArrowDown = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" style={{margin: '0 auto'}}>
                <path d="M12 5v14M19 12l-7 7-7-7"/>
            </svg>
        );

        const ArrowLeft = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" style={{margin: '0 auto'}}>
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
        );

        const ArrowRight = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" style={{margin: '0 auto'}}>
                <path d="M5 12h14M12 5l7 7-7 7"/>
            </svg>
        );

        const RotateCcw = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                <path d="M3 3v5h5"/>
            </svg>
        );

        function MergeBattle() {
            const [playerGrid, setPlayerGrid] = useState(initGrid);
            const [aiGrid, setAiGrid] = useState(initGrid);
            const [playerScore, setPlayerScore] = useState(0);
            const [aiScore, setAiScore] = useState(0);
            const [gameOver, setGameOver] = useState({ player: false, ai: false });
            const [winner, setWinner] = useState(null);
            const [showModal, setShowModal] = useState(false);

            // AI speed per-move (ms)
            const [aiDelay, setAiDelay] = useState(700);

            // Timed-round state
            const ROUND_MS_DEFAULT = 180000; // 3 minutes
            const [isTimedRound, setIsTimedRound] = useState(false);
            const [timeLeft, setTimeLeft] = useState(0);
            const roundDurationRef = useRef(ROUND_MS_DEFAULT);

            const aiIntervalRef = useRef(null);
            const aiTimeoutRef = useRef(null); // for single-response after player move
            const timerIntervalRef = useRef(null);
            const gameStateRef = useRef({ player: false, ai: false });

            // NEW: refs to avoid stale closures
            const isTimedRoundRef = useRef(false);
            const playerScoreRef = useRef(0);
            const aiScoreRef = useRef(0);

            // keep refs in sync with state
            useEffect(() => { gameStateRef.current = gameOver; }, [gameOver]);
            useEffect(() => { isTimedRoundRef.current = isTimedRound; }, [isTimedRound]);
            useEffect(() => { playerScoreRef.current = playerScore; }, [playerScore]);
            useEffect(() => { aiScoreRef.current = aiScore; }, [aiScore]);

            // AI move ‚Äî returns immediately if timed round stopped
            const performAiMove = useCallback(() => {
                // If timed round was stopped, do nothing.
                if (isTimedRoundRef.current === false && !isTimedRound) return;

                // If non-timed mode and AI already finished, do nothing
                if (!isTimedRoundRef.current && gameStateRef.current.ai) return;

                setAiGrid(prevGrid => {
                    const direction = aiMove(prevGrid);
                    if (direction) {
                        const result = move(prevGrid, direction);
                        addRandomTile(result.grid);
                        setAiScore(prev => prev + result.score);

                        // If no moves left for AI, mark finished (non-timed)
                        if (!canMove(result.grid)) {
                            setGameOver(prev => ({ ...prev, ai: true }));
                            if (aiIntervalRef.current) {
                                clearInterval(aiIntervalRef.current);
                                aiIntervalRef.current = null;
                            }
                        }
                        return result.grid;
                    } else {
                        setGameOver(prev => ({ ...prev, ai: true }));
                        if (aiIntervalRef.current) {
                            clearInterval(aiIntervalRef.current);
                            aiIntervalRef.current = null;
                        }
                        return prevGrid;
                    }
                });
            }, [isTimedRound]);

            const handlePlayerMove = useCallback((direction) => {
                // if player finished in non-timed mode, don't allow moves
                if (!isTimedRoundRef.current && gameStateRef.current.player) return;
                if (showModal) return;

                setPlayerGrid(prevGrid => {
                    const result = move(prevGrid, direction);
                    if (result.moved) {
                        addRandomTile(result.grid);
                        setPlayerScore(prev => prev + result.score);

                        if (!canMove(result.grid)) {
                            setGameOver(prev => ({ ...prev, player: true }));
                        } else {
                            // Non-timed mode: schedule immediate AI response after aiDelay
                            if (!isTimedRoundRef.current) {
                                if (!gameStateRef.current.ai) {
                                    if (aiTimeoutRef.current) {
                                        clearTimeout(aiTimeoutRef.current);
                                        aiTimeoutRef.current = null;
                                    }
                                    aiTimeoutRef.current = setTimeout(() => {
                                        performAiMove();
                                        aiTimeoutRef.current = null;
                                    }, aiDelay);
                                }
                            }
                            // Timed round: AI runs on interval only
                        }
                        return result.grid;
                    }
                    return prevGrid;
                });
            }, [showModal, aiDelay, performAiMove]);

            // Start AI auto-play when player finishes (non-timed behavior)
            useEffect(() => {
                if (!isTimedRoundRef.current) {
                    if (gameOver.player && !gameOver.ai && !aiIntervalRef.current) {
                        aiIntervalRef.current = setInterval(() => {
                            performAiMove();
                        }, aiDelay);
                    }
                }
                // we intentionally don't cleanup here because other places clear on reset/stop
            }, [gameOver.player, gameOver.ai, aiDelay, performAiMove]);

            // If aiDelay changes and an interval exists, restart it to use new delay
            useEffect(() => {
                if (aiIntervalRef.current) {
                    clearInterval(aiIntervalRef.current);
                    aiIntervalRef.current = setInterval(() => {
                        performAiMove();
                    }, aiDelay);
                }
            }, [aiDelay, performAiMove]);

            // TIMED ROUND: start a fresh game and run both players for exactly roundDurationRef.current
            const startTimedRound = (durationMs = ROUND_MS_DEFAULT) => {
                // Clear any existing timers
                if (aiIntervalRef.current) { clearInterval(aiIntervalRef.current); aiIntervalRef.current = null; }
                if (aiTimeoutRef.current) { clearTimeout(aiTimeoutRef.current); aiTimeoutRef.current = null; }
                if (timerIntervalRef.current) { clearInterval(timerIntervalRef.current); timerIntervalRef.current = null; }

                // Reset state
                setPlayerGrid(initGrid());
                setAiGrid(initGrid());
                setPlayerScore(0);
                setAiScore(0);
                setGameOver({ player: false, ai: false });
                gameStateRef.current = { player: false, ai: false };
                setWinner(null);
                setShowModal(false);

                // Set timed round flags
                setIsTimedRound(true);
                isTimedRoundRef.current = true;
                setTimeLeft(durationMs);
                roundDurationRef.current = durationMs;

                // Start AI automatic moves on interval using aiDelay
                aiIntervalRef.current = setInterval(() => {
                    // performAiMove will check isTimedRoundRef
                    performAiMove();
                }, aiDelay);

                // Start countdown using absolute start time to avoid drift
                const startTs = Date.now();
                timerIntervalRef.current = setInterval(() => {
                    const elapsed = Date.now() - startTs;
                    const left = Math.max(0, durationMs - elapsed);
                    setTimeLeft(left);

                    if (left <= 0) {
                        // Stop round and all AI activity immediately
                        stopTimedRound();

                        // Compute winner using up-to-date refs (avoids stale closure values)
                        const pScore = playerScoreRef.current;
                        const aScore = aiScoreRef.current;
                        if (pScore > aScore) setWinner('player');
                        else if (aScore > pScore) setWinner('ai');
                        else setWinner('tie');
                        setShowModal(true);
                    }
                }, 250); // check frequently for responsiveness
            };

            // Stop an ongoing timed round early (cleanup)
            const stopTimedRound = () => {
                if (timerIntervalRef.current) { clearInterval(timerIntervalRef.current); timerIntervalRef.current = null; }
                if (aiIntervalRef.current) { clearInterval(aiIntervalRef.current); aiIntervalRef.current = null; }
                if (aiTimeoutRef.current) { clearTimeout(aiTimeoutRef.current); aiTimeoutRef.current = null; }
                setIsTimedRound(false);
                isTimedRoundRef.current = false;
                setTimeLeft(0);
            };

            // Check for winner when both finish (old non-timed behavior)
            useEffect(() => {
                if (!isTimedRoundRef.current && gameOver.player && gameOver.ai && !winner) {
                    setTimeout(() => {
                        if (playerScoreRef.current > aiScoreRef.current) setWinner('player');
                        else if (aiScoreRef.current > playerScoreRef.current) setWinner('ai');
                        else setWinner('tie');
                        setShowModal(true);
                    }, 300);
                }
            }, [gameOver, winner]);

            // Keyboard controls
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (showModal) return;
                    const keyMap = { 'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right' };
                    const direction = keyMap[e.key];
                    if (direction) {
                        e.preventDefault();
                        handlePlayerMove(direction);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handlePlayerMove, showModal]);

            const resetGame = () => {
                if (aiIntervalRef.current) { clearInterval(aiIntervalRef.current); aiIntervalRef.current = null; }
                if (aiTimeoutRef.current) { clearTimeout(aiTimeoutRef.current); aiTimeoutRef.current = null; }
                if (timerIntervalRef.current) { clearInterval(timerIntervalRef.current); timerIntervalRef.current = null; }
                setPlayerGrid(initGrid());
                setAiGrid(initGrid());
                setPlayerScore(0);
                setAiScore(0);
                setGameOver({ player: false, ai: false });
                gameStateRef.current = { player: false, ai: false };
                setWinner(null);
                setShowModal(false);
                setIsTimedRound(false);
                isTimedRoundRef.current = false;
                setTimeLeft(0);
            };

            const Grid = ({ grid }) => (
                <div className="inline-block bg-gray-300 p-2 rounded-lg">
                    {grid.map((row, r) => (
                        <div key={r} className="flex gap-2 mb-2 last:mb-0">
                            {row.map((cell, c) => (
                                <div
                                    key={`${r}-${c}`}
                                    className={`w-16 h-16 flex items-center justify-center text-xl font-bold rounded ${
                                        cell === 0 ? 'bg-gray-200' : COLORS[cell] || 'bg-purple-600 text-white'
                                    }`}
                                >
                                    {cell !== 0 && cell}
                                </div>
                            ))}
                        </div>
                    ))}
                </div>
            );

            // helper to format remaining time
            const formatTime = (ms) => {
                const s = Math.ceil(ms/1000);
                const min = Math.floor(s/60).toString().padStart(2,'0');
                const sec = (s % 60).toString().padStart(2,'0');
                return `${min}:${sec}`;
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-purple-100 to-blue-100 p-8">
                    <div className="max-w-6xl mx-auto">
                        <h1 className="text-4xl font-bold text-center mb-2 text-gray-800">2048 Battle - Timed Round</h1>
                        <p className="text-center text-gray-600 mb-8">Play against the AI. Start a 3-minute round ‚Äî whoever has more points when time's up wins.</p>
                        
                        <div className="flex justify-center gap-4 mb-6">
                            <div className="bg-white p-4 rounded shadow">
                                <div className="text-sm text-gray-600">AI per-move delay</div>
                                <div className="flex gap-2 mt-2">
                                    <button onClick={() => setAiDelay(300)} className={`px-3 py-1 rounded ${aiDelay===300 ? 'bg-blue-600 text-white' : 'bg-white border'}`}>Fast</button>
                                    <button onClick={() => setAiDelay(700)} className={`px-3 py-1 rounded ${aiDelay===700 ? 'bg-blue-600 text-white' : 'bg-white border'}`}>Default</button>
                                    <button onClick={() => setAiDelay(1500)} className={`px-3 py-1 rounded ${aiDelay===1500 ? 'bg-blue-600 text-white' : 'bg-white border'}`}>Slow</button>
                                </div>
                            </div>

                            <div className="bg-white p-4 rounded shadow flex flex-col items-center justify-center">
                                <div className="text-sm text-gray-600 mb-2">Timed round</div>
                                <div className="flex gap-2">
                                    <button
                                        onClick={() => startTimedRound(180000)}
                                        className="bg-purple-600 text-white px-4 py-2 rounded font-semibold shadow hover:opacity-90"
                                    >
                                        Start 3 min Round
                                    </button>
                                    <button
                                        onClick={() => stopTimedRound()}
                                        className="bg-yellow-400 text-white px-4 py-2 rounded font-semibold shadow hover:opacity-90"
                                    >
                                        Stop Round
                                    </button>
                                </div>
                                <div className="text-xs text-gray-500 mt-2">When round ends, the higher score wins.</div>
                            </div>

                            <div className="bg-white p-4 rounded shadow flex flex-col items-center justify-center">
                                <div className="text-sm text-gray-600">Round timer</div>
                                <div className="text-2xl font-bold mt-1 text-gray-800">{ isTimedRound ? formatTime(timeLeft) : '--:--' }</div>
                                <div className="text-xs text-gray-500 mt-1">{ isTimedRound ? 'Round running' : 'No active round' }</div>
                            </div>
                        </div>

                        <div className="grid md:grid-cols-2 gap-8 mb-8">
                            <div className="bg-white p-6 rounded-xl shadow-lg">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-2xl font-bold text-blue-600">You</h2>
                                    <div className="text-right">
                                        <div className="text-sm text-gray-600">Score</div>
                                        <div className="text-2xl font-bold text-blue-600">{playerScore}</div>
                                    </div>
                                </div>
                                <Grid grid={playerGrid} />
                                {!isTimedRound && gameOver.player && !gameOver.ai && (
                                    <div className="mt-4 text-orange-600 font-semibold">
                                        ‚è∏Ô∏è Waiting for AI to finish...
                                    </div>
                                )}
                            </div>
                            
                            <div className="bg-white p-6 rounded-xl shadow-lg">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-2xl font-bold text-red-600">AI</h2>
                                    <div className="text-right">
                                        <div className="text-sm text-gray-600">Score</div>
                                        <div className="text-2xl font-bold text-red-600">{aiScore}</div>
                                    </div>
                                </div>
                                <Grid grid={aiGrid} />
                                {!isTimedRound && gameOver.ai && !gameOver.player && (
                                    <div className="mt-4 text-orange-600 font-semibold">
                                        ‚è∏Ô∏è AI finished! Your turn...
                                    </div>
                                )}
                            </div>
                        </div>

                        <div className="bg-white p-6 rounded-xl shadow-lg mb-6">
                            <div className="flex flex-col items-center gap-4">
                                <div className="text-center">
                                    <h3 className="font-bold text-lg mb-2">Controls</h3>
                                    <div className="grid grid-cols-3 gap-2 mb-4">
                                        <div></div>
                                        <button
                                            onClick={() => handlePlayerMove('up')}
                                            className="bg-blue-500 text-white p-3 rounded hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
                                            disabled={!isTimedRound && gameOver.player || showModal}
                                        >
                                            <ArrowUp />
                                        </button>
                                        <div></div>
                                        <button
                                            onClick={() => handlePlayerMove('left')}
                                            className="bg-blue-500 text-white p-3 rounded hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
                                            disabled={!isTimedRound && gameOver.player || showModal}
                                        >
                                            <ArrowLeft />
                                        </button>
                                        <button
                                            onClick={() => handlePlayerMove('down')}
                                            className="bg-blue-500 text-white p-3 rounded hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
                                            disabled={!isTimedRound && gameOver.player || showModal}
                                        >
                                            <ArrowDown />
                                        </button>
                                        <button
                                            onClick={() => handlePlayerMove('right')}
                                            className="bg-blue-500 text-white p-3 rounded hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed"
                                            disabled={!isTimedRound && gameOver.player || showModal}
                                        >
                                            <ArrowRight />
                                        </button>
                                    </div>
                                    <p className="text-sm text-gray-600">Or use arrow keys</p>
                                </div>
                                
                                <button
                                    onClick={resetGame}
                                    className="bg-green-500 text-white px-6 py-3 rounded-lg hover:bg-green-600 flex items-center gap-2 font-semibold"
                                >
                                    <RotateCcw />
                                    New Game (reset)
                                </button>
                            </div>
                        </div>

                        {/* Victory/Loss Modal */}
                        {showModal && winner && (
                            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                                <div className={`bg-white rounded-2xl shadow-2xl p-8 max-w-md w-full animate-slide-down ${
                                    winner === 'player' ? 'border-4 border-green-500' : 
                                    winner === 'ai' ? 'border-4 border-red-500' : 
                                    'border-4 border-yellow-500'
                                }`}>
                                    <div className="text-center">
                                        {winner === 'player' && (
                                            <>
                                                <div className="text-6xl mb-4">üéâ</div>
                                                <h2 className="text-4xl font-bold text-green-600 mb-2">
                                                    CONGRATULATIONS!
                                                </h2>
                                                <p className="text-2xl font-semibold text-gray-800 mb-4">
                                                    You Won! üèÜ
                                                </p>
                                            </>
                                        )}
                                        {winner === 'ai' && (
                                            <>
                                                <div className="text-6xl mb-4">üòî</div>
                                                <h2 className="text-4xl font-bold text-red-600 mb-2">
                                                    ROUND OVER
                                                </h2>
                                                <p className="text-2xl font-semibold text-gray-800 mb-4">
                                                    AI has more points.
                                                </p>
                                            </>
                                        )}
                                        {winner === 'tie' && (
                                            <>
                                                <div className="text-6xl mb-4">ü§ù</div>
                                                <h2 className="text-4xl font-bold text-yellow-600 mb-2">
                                                    IT'S A TIE!
                                                </h2>
                                                <p className="text-2xl font-semibold text-gray-800 mb-4">
                                                    Well played! ‚öñÔ∏è
                                                </p>
                                            </>
                                        )}
                                        
                                        <div className="bg-gray-100 rounded-lg p-4 mb-6">
                                            <div className="flex justify-between items-center mb-2">
                                                <span className="text-lg font-semibold text-blue-600">Your Score:</span>
                                                <span className="text-2xl font-bold text-blue-600">{playerScore}</span>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <span className="text-lg font-semibold text-red-600">AI Score:</span>
                                                <span className="text-2xl font-bold text-red-600">{aiScore}</span>
                                            </div>
                                            <div className="mt-3 pt-3 border-t-2 border-gray-300">
                                                <div className="flex justify-between items-center">
                                                    <span className="text-lg font-semibold text-gray-700">Difference:</span>
                                                    <span className="text-xl font-bold text-gray-800">
                                                        {Math.abs(playerScore - aiScore)} points
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <button
                                            onClick={() => { resetGame(); }}
                                            className="w-full bg-gradient-to-r from-purple-500 to-blue-500 text-white px-8 py-4 rounded-lg hover:from-purple-600 hover:to-blue-600 font-bold text-lg shadow-lg transform transition hover:scale-105"
                                        >
                                            Play Again / Reset üéÆ
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<MergeBattle />, document.getElementById('root'));
    </script>
</body>
</html>
